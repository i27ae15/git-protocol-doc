"use strict";(self.webpackChunkgit_protocol=self.webpackChunkgit_protocol||[]).push([[456],{2517:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"git-protocol/reading-pack-file","title":"6. Reading Pack File","description":"At this point, we have all the necessary components to start reading the pack file. Parsing the OFS_DELTA is not required to complete this stage,","source":"@site/docs/git-protocol/reading-pack-file.md","sourceDirName":"git-protocol","slug":"/git-protocol/reading-pack-file","permalink":"/git-protocol-doc/docs/git-protocol/reading-pack-file","draft":false,"unlisted":false,"editUrl":"https://github.com/i27ae15/git-protocol-doc/docs/git-protocol/reading-pack-file.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"5. Parsing REF_DELTA","permalink":"/git-protocol-doc/docs/git-protocol/ref-delta"},"next":{"title":"Blob","permalink":"/git-protocol-doc/docs/objects/blob"}}');var r=n(4848),o=n(8453);const c={sidebar_position:7},s="6. Reading Pack File",a={},d=[{value:"Step 1: Reading the Pack File Header",id:"step-1-reading-the-pack-file-header",level:3},{value:"Step 2: Processing Each Object",id:"step-2-processing-each-object",level:3},{value:"Step 3: Writing to the Objects Folder",id:"step-3-writing-to-the-objects-folder",level:3},{value:"Step 4: Updating the Working Directory",id:"step-4-updating-the-working-directory",level:3}];function l(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"6-reading-pack-file",children:"6. Reading Pack File"})}),"\n",(0,r.jsxs)(t.p,{children:["At this point, we have all the necessary components to start reading the pack file. Parsing the ",(0,r.jsx)(t.code,{children:"OFS_DELTA"})," is not required to complete this stage,\nso the only thing that we have to do now is putting all together."]}),"\n",(0,r.jsx)(t.p,{children:"But first, just a few points to remember:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Storing Pack-File Objects:"}),"\nAll the objects included in the pack file must be written to the ",(0,r.jsx)(t.code,{children:".git/objects"})," folder."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Updating the Working Directory:"}),"\nOnly the objects directly referenced by the HEAD (such as the current branch) should be written to the working directory."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"A basic implementation for handling the object headers might look like this:"}),"\n",(0,r.jsx)(t.h3,{id:"step-1-reading-the-pack-file-header",children:"Step 1: Reading the Pack File Header"}),"\n",(0,r.jsx)(t.p,{children:"The pack file begins with a header, which provides the total number of objects."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"struct PackFileHeader {\n    uint32_t version;  // Pack file version, usually 2 or 3\n    uint32_t numObjects; // Total objects in the pack file\n};\n\nPackFileHeader header = readPackFileHeader(&header);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"step-2-processing-each-object",children:"Step 2: Processing Each Object"}),"\n",(0,r.jsx)(t.p,{children:"Iterate through the objects, parsing their headers and processing based on their type."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"std::vector<uint8_t> packFile = getPackFile();\n\nfor (uint32_t i {}; i < header.numObjects; i++) {\n    ObjectHeader objHeader {};\n    readObjectHeader(&objHeader, packFile);\n\n    switch (objHeader.type) {\n        case COMMIT:\n            (void)processCommit(packFile);\n            break;\n\n        case TREE:\n            (void)processTree(packFile);\n            break;\n\n        case BLOB:\n            (void)processBlob(packFile);\n            break;\n\n        case REF_DELTA:\n            (void)processRefDelta(packFile);\n            break;\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"step-3-writing-to-the-objects-folder",children:"Step 3: Writing to the Objects Folder"}),"\n",(0,r.jsxs)(t.p,{children:["Each processed object is stored in ",(0,r.jsx)(t.code,{children:".git/objects"})," using its SHA-1 hash:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void writeObjectToDisk(const ObjectHeader& header, const std::string& objectData) {\n    std::string objectHash = calculateSHA1(objectData);\n    std::string objectPath = generateObjectPath(objectHash);\n\n    createDirectoriesIfNeeded(objectPath);\n    writeToFile(objectPath, objectData);\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"step-4-updating-the-working-directory",children:"Step 4: Updating the Working Directory"}),"\n",(0,r.jsx)(t.p,{children:"For objects referenced by the HEAD, extract and write them to the appropriate locations in the working directory."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void updateWorkingDirectory(const ObjectHeader& header, const std::string& objectData) {\n    if (isReferencedByHead(header)) {\n        std::string filePath = getWorkingDirectoryPath(header);\n        writeToFile(filePath, objectData);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"And that should be it!"})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>s});var i=n(6540);const r={},o=i.createContext(r);function c(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);