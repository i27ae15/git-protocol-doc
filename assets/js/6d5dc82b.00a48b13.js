"use strict";(self.webpackChunkgit_protocol=self.webpackChunkgit_protocol||[]).push([[935],{8794:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>a,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"git-protocol/object-header","title":"4. Object Header","description":"In the pack file, each object includes a header that indicates two key pieces of information:","source":"@site/docs/git-protocol/object-header.md","sourceDirName":"git-protocol","slug":"/git-protocol/object-header","permalink":"/git-protocol-doc/docs/git-protocol/object-header","draft":false,"unlisted":false,"editUrl":"https://github.com/i27ae15/git-protocol-doc/docs/git-protocol/object-header.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"3. Pack Header","permalink":"/git-protocol-doc/docs/git-protocol/pack-header"},"next":{"title":"5. Parsing REF_DELTA","permalink":"/git-protocol-doc/docs/git-protocol/ref-delta"}}');var s=i(4848),c=i(8453);const o={sidebar_position:5},r="4. Object Header",h={},d=[{value:"Structure of the Headers",id:"structure-of-the-headers",level:3},{value:"Extracting the Object Type",id:"extracting-the-object-type",level:3},{value:"Example:",id:"example",level:3},{value:"Extracting the Object Size",id:"extracting-the-object-size",level:3},{value:"Example:",id:"example-1",level:4},{value:"Handling Multi-Byte Sizes",id:"handling-multi-byte-sizes",level:3},{value:"Example:",id:"example-2",level:4}];function l(e){const t={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"4-object-header",children:"4. Object Header"})}),"\n",(0,s.jsxs)("div",{class:"justified-text",children:[(0,s.jsx)(t.p,{children:"In the pack file, each object includes a header that indicates two key pieces of information:"}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:"The type of the file object:"})}),"\n"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"COMMIT = 1"}),"\n",(0,s.jsx)(t.li,{children:"TREE = 2"}),"\n",(0,s.jsx)(t.li,{children:"BLOB = 3"}),"\n",(0,s.jsx)(t.li,{children:"TAG = 4"}),"\n",(0,s.jsx)(t.li,{children:"OFS_DELTA = 6"}),"\n",(0,s.jsx)(t.li,{children:"REF_DELTA = 7"}),"\n"]}),(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:"The size this object takes in the pack-file"})}),"\n"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["This represents the ",(0,s.jsx)(t.strong,{children:"uncompressed"})," size, not the ",(0,s.jsx)(t.strong,{children:"compressed"})," one! This is helpful because we can tell z-lib to allocate the correct amount of memory for\ndecompression."]}),"\n"]}),(0,s.jsx)(t.h3,{id:"structure-of-the-headers",children:"Structure of the Headers"}),(0,s.jsx)(t.p,{children:"The header data is packed into bytes as follows:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bits 6-4"}),": Store the object type."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bits 3-0"}),": Store the size."]}),"\n"]}),(0,s.jsxs)(t.p,{children:["The size field can extend across multiple bytes if the Most Significant Bit (MSB and\nwill refer as it now on) of a byte is set to ",(0,s.jsx)(t.code,{children:"1"}),", indicating continuation for the size."]}),(0,s.jsx)(t.p,{children:"If you're unfamiliar on how packing, here is an explanation:"}),(0,s.jsx)(t.h3,{id:"extracting-the-object-type",children:"Extracting the Object Type"}),(0,s.jsxs)(t.p,{children:["For extracting the ",(0,s.jsx)(t.code,{children:"type"})," the bits ",(0,s.jsx)(t.code,{children:"6-4"})," must be checked, this can be done by:"]}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Shifting the byte 4 bits to the right."}),"\n",(0,s.jsxs)(t.li,{children:["Look for a byte that has ",(0,s.jsx)(t.code,{children:"111"})," at the right most bits."]}),"\n",(0,s.jsxs)(t.li,{children:["Use the ",(0,s.jsx)(t.code,{children:"AND (&)"})," operator to isolated the bits ",(0,s.jsx)(t.code,{children:"6 - 4"})," which now are going to be in position ",(0,s.jsx)(t.code,{children:"2-0"})]}),"\n"]}),(0,s.jsx)(t.h3,{id:"example",children:"Example:"}),(0,s.jsxs)(t.p,{children:["Consider the header byte ",(0,s.jsx)(t.code,{children:"\\xDE"})," (",(0,s.jsx)(t.code,{children:"1101 1110"})," in binary). The bits ",(0,s.jsx)(t.code,{children:"101"})," represent the type, so these are the one we want to isolate; the byte ",(0,s.jsx)(t.code,{children:"\\x07"})," can helps us do this,\nsince its binary is ",(0,s.jsx)(t.code,{children:"0000 0111"}),", thus we can simply make an ",(0,s.jsx)(t.code,{children:"AND"})," operation after shifting by 4, so we get the correct value:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"BYTE = 0xDE;  // 1101 1110\nBYTE >> 4;    // 0000 1101\n"})}),(0,s.jsxs)(t.p,{children:["Now, we are good to perform the ",(0,s.jsx)(t.code,{children:"AND"})," operation:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"BYTE & \\x07\n\n\\xDE   : 0000 1101 &\n\\x07   : 0000 0111\nRESULT : 0000 1101\n"})}),(0,s.jsxs)(t.p,{children:["And if we convert the result into decimal we get that the value for our type is ",(0,s.jsx)(t.code,{children:"3"})," which corresponds to a ",(0,s.jsx)(t.code,{children:"BLOB"})," object."]}),(0,s.jsx)(t.p,{children:"Now, that we have covered the type, is time to look at the size of the object, the size tha its uncompressed values occupy."}),(0,s.jsxs)(t.p,{children:["For this, we have to look in the same byte, but bits ",(0,s.jsx)(t.code,{children:"3 - 0"}),", we can simply extract it with the ",(0,s.jsx)(t.code,{children:"AND"})," operator with a byte that has all its 1s at the right most part, for example we can use ",(0,s.jsx)(t.code,{children:"\\x0F"}),"."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"BYTE : 1101 1110 (\\xDE)\n\n\\xDE & \\x0F\n\n\\xDE   : 1101 1110 &\n\\x0F   : 0000 1111\nRESULT : 0000 1110\n"})}),(0,s.jsxs)(t.p,{children:["Which converted to decimal gives us ",(0,s.jsx)(t.code,{children:"14"}),"."]}),(0,s.jsxs)(t.p,{children:["So, perfect right? we have our ",(0,s.jsx)(t.code,{children:"type"})," a blob object, and the size of this blob object, ",(0,s.jsx)(t.code,{children:"14"}),", we are good to go! Well not\nthat fast, because there could be more data corresponding to the size in the next byte, which is encoded in the ",(0,s.jsx)(t.code,{children:"MSB"}),", so\nin order to check if we are good to start reading the blob or if we have to increase the size, we have to check it. This\ncould be done in two ways, either we check the ",(0,s.jsx)(t.code,{children:"MSB"})," directly with an ",(0,s.jsx)(t.code,{children:"AND"})," operation or we check if the byte is bigger\nthan ",(0,s.jsx)(t.code,{children:"127"}),". In this case, we can see that in the current byte ",(0,s.jsx)(t.code,{children:"1101 1110"})," its MSB is ",(0,s.jsx)(t.code,{children:"1"})," indicating that the next byte in\nthe stream is also part of the size. Let's take a look."]}),(0,s.jsxs)(t.p,{children:["The next byte we see that is ",(0,s.jsx)(t.code,{children:"1110 0110"})," or ",(0,s.jsx)(t.code,{children:"\\xE6"}),", this time, the bits ",(0,s.jsx)(t.code,{children:"6 - 0"})," are for the size, and the MSB still tell\nus if the next byte is part of the size or not. How do we add this size? Simply, just combining it to our current size:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"SIZE = 0000 1110 (\\x0E)\n\n\\x0E | \\xE6\n\n\\x0E : 0000 1110 |\n\\xE6 : 1110 0110\nSIZE : 1110 1110\n"})}),(0,s.jsxs)(t.p,{children:["And this converted to decimal equals ",(0,s.jsx)(t.code,{children:"238"}),", and again, the MSB tells us that there is more. But, you can notice that\n",(0,s.jsx)(t.code,{children:"255"})," was possible to be reached just in this step, and we cannot add more than ",(0,s.jsx)(t.code,{children:"255"})," in one byte, so what do we do? We\nshift the next byte, not by 8, but by 7, why 7 ? Because the MSB is not part of the size, so we cannot count it."]}),(0,s.jsxs)(t.p,{children:["We check and the next byte is ",(0,s.jsx)(t.code,{children:"1001 1111"}),", we do the same procedure, but before combining it to our current size, we shift\nit by 7 positions."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"BYTE = 1001 1111 (\\x9F)\n\nBYTE << 7\nBYTE = 0100 1111 1000 0000\n       ^          ^......^ These are the bytes shifted\n       Adding a zero\n       here to better\n       visualization\n"})}),(0,s.jsx)(t.p,{children:"So, we are good to combine them:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"SIZE = 1110 1110 (\\xEE)\nBYTE = 0100 1111 1000 0000 (\\x4F80)\n\n\\xEE | \\x4f80\n\n\\xEE   : 0000 0000 1110 1110 |\n\\x4F80 : 0100 1111 1000 0000\nSIZE   : 0100 1111 1110 1110\n"})}),(0,s.jsxs)(t.p,{children:["Which converted to decimal gives : ",(0,s.jsx)(t.code,{children:"20462"}),"."]}),(0,s.jsxs)(t.p,{children:["Perfect, checking the MSB we see that also the next byte is part of the size, so this time, instead of ",(0,s.jsx)(t.code,{children:"7"})," positions, we\nhave to shift ",(0,s.jsx)(t.code,{children:"14"}),", and so on."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:" BYTE_0   -    BYTE_1    -    BYTE_0    -   BYTE_0     -     BYTE_N\nSHIFT(0)  -   SHIFT(7)   -  SHIFT(14)   -  SHIFT(21)   -  SHIFT_(7 * N)\n"})}),(0,s.jsx)(t.p,{children:"In case you need a more straightforward explanation here it is:"}),(0,s.jsx)(t.h3,{id:"extracting-the-object-size",children:"Extracting the Object Size"}),(0,s.jsxs)(t.p,{children:["The size is stored in bits ",(0,s.jsx)(t.code,{children:"3-0"})," of the header byte. To isolate these bits:"]}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Use the ",(0,s.jsx)(t.code,{children:"AND"})," operator with a mask (",(0,s.jsx)(t.code,{children:"0x0F"})," in hexadecimal, ",(0,s.jsx)(t.code,{children:"0000 1111"})," in binary)."]}),"\n"]}),(0,s.jsx)(t.h4,{id:"example-1",children:"Example:"}),(0,s.jsxs)(t.p,{children:["From the same byte ",(0,s.jsx)(t.code,{children:"\\xDE"}),":"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"BYTE = 0xDE;  // 1101 1110\nBYTE & 0x0F;  // 0000 1110 (size = 14)\n"})}),(0,s.jsxs)(t.p,{children:["The result is ",(0,s.jsx)(t.code,{children:"14"})," (the uncompressed size of the object)."]}),(0,s.jsx)(t.h3,{id:"handling-multi-byte-sizes",children:"Handling Multi-Byte Sizes"}),(0,s.jsxs)(t.p,{children:["If the MSB of a byte is ",(0,s.jsx)(t.code,{children:"1"}),", it indicates that the size continues into the next byte. To handle this:"]}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Extract the current size bits (",(0,s.jsx)(t.code,{children:"6-0"}),") by masking with ",(0,s.jsx)(t.code,{children:"0x7F"})," (",(0,s.jsx)(t.code,{children:"0111 1111"})," in binary)."]}),"\n",(0,s.jsx)(t.li,{children:"Check the MSB to determine if there is another byte."}),"\n",(0,s.jsxs)(t.li,{children:["If there is, shift the next byte\u2019s bits by ",(0,s.jsx)(t.code,{children:"7"})," positions (for the first additional byte) and combine it with the current size using the ",(0,s.jsx)(t.code,{children:"OR"})," operator."]}),"\n"]}),(0,s.jsx)(t.h4,{id:"example-2",children:"Example:"}),(0,s.jsx)(t.p,{children:"Let\u2019s say the size spans three bytes:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["First byte: ",(0,s.jsx)(t.code,{children:"\\xDE"})," (",(0,s.jsx)(t.code,{children:"1101 1110"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:["Second byte: ",(0,s.jsx)(t.code,{children:"\\xE6"})," (",(0,s.jsx)(t.code,{children:"1110 0110"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:["Third byte: ",(0,s.jsx)(t.code,{children:"\\x9F"})," (",(0,s.jsx)(t.code,{children:"1001 1111"}),")"]}),"\n"]}),(0,s.jsx)(t.p,{children:"Step-by-step calculation:"}),(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Extract the size from the first byte:"}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"SIZE = 0x0E;  // 0000 1110 (size from \\xDE)\n"})}),(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsx)(t.li,{children:"Combine with the second byte:"}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"BYTE = 0xE6;  // 1110 0110\nBYTE & 0x7F;  // 0110 0110 (remove MSB)\nSIZE = (SIZE | (BYTE << 7));\n"})}),(0,s.jsxs)(t.p,{children:["Result: ",(0,s.jsx)(t.code,{children:"SIZE = 0xEE"})," (",(0,s.jsx)(t.code,{children:"1110 1110"}),", decimal ",(0,s.jsx)(t.code,{children:"238"}),")."]}),(0,s.jsxs)(t.ol,{start:"3",children:["\n",(0,s.jsx)(t.li,{children:"Combine with the third byte, shifted by 14 positions:"}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"BYTE = 0x9F;  // 1001 1111\nBYTE & 0x7F;  // 0001 1111\nSIZE = (SIZE | (BYTE << 14));\n"})}),(0,s.jsxs)(t.p,{children:["Result: ",(0,s.jsx)(t.code,{children:"SIZE = 0x4FEE"})," (",(0,s.jsx)(t.code,{children:"0100 1111 1110 1110"}),", decimal ",(0,s.jsx)(t.code,{children:"20462"}),")."]}),(0,s.jsxs)(t.ol,{start:"4",children:["\n",(0,s.jsxs)(t.li,{children:["Continue this process for additional bytes, shifting each subsequent byte by ",(0,s.jsx)(t.code,{children:"7"})," more positions than the last:"]}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:" BYTE_0    -    BYTE_1    -    BYTE_0    -    BYTE_0    -    BYTE_N\nSHIFT(0)   -   SHIFT(7)   -  SHIFT(14)   -  SHIFT(21)   -  SHIFT_(7 * N)\n"})})]})]})}function a(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(6540);const s={},c=n.createContext(s);function o(e){const t=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(c.Provider,{value:t},e.children)}}}]);